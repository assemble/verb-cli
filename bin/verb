#!/usr/bin/env node

process.title = 'verb';

/**
 * A few tricks in this file were gleaned from
 * node-liftoff and gulp's cli.
 */

const path = require('path');
const cwd = require('cwd');
const file = require('fs-utils');
const configFile = require('config-file');
const relative = require('relative');
const argv = require('minimist')(process.argv.slice(2));
const Liftoff = require('liftoff');
const log = require('verbalize');
const _ = require('lodash');

// Verbalize `runner`
log.runner = 'verb-cli';

var localConfig = {};
var rc = '';

if (file.exists('.verbrc.yml')) {
  rc = '.verbrc.yml';
  localConfig = configFile.load(rc);
} else if (file.exists('.verbrc')) {
  rc = '.verbrc';
  localConfig = configFile.load(rc);
}

/**
 * If a verbfile.js exists, give that to liftoff,
 * if not, use the runtime config instead.
 */

var vf = file.exists('verbfile.js') ? 'verbfile' : '.verb';


/**
 * Liftoff
 */

var cli = new Liftoff({
  name: 'verb',
  configName: vf,
  addExtensions: ['rc', 'rc.yml', 'rc.md', 'js'],
  preloadFlag: 'require',
  completionFlag: 'completion',
  completions: function () {
    log.warn('Completions not implemented.');
  }
});


cli.on('require', function (name, module) {
  if (name === 'coffee-script') {
    module.register();
  }
  log.writeln('  Requiring external module:', name);
});


cli.on('requireFail', function (name, err) {
  log.writeln('  Unable to require external module:', name, err);
});


/**
 * Logging messages
 */

var msg = {
  noTemplates: function(dir) {
    var text = [
      '  verb-cli [skipping] Â· ' + log.bold('no templates found in \'' + dir + '\'.'),
      '                        ' + log.gray('verb-cli requires templates to have a \'.tmpl.md\' extension.'),
      '                        ' + log.gray('Visit the verb-cli project to learn how to customize this:'),
      '                        https://github.com/assemble/verb-cli'
    ].join('\n');
    return text;
  },
  displayHelp: function() {
    log.writeln();
    log.writeln('  Usage:');
    log.writeln(log.gray('   List repos for a user:'), log.bold(' repos USERNAME [args]'));
    log.writeln(log.gray('   List repos for an org:'), log.bold(' repos -o ORG-NAME [args]'));
    log.writeln();
    log.writeln('  General options:');
    log.writeln('   -h, --help', log.gray(' # Print options and usage information.'));
    log.writeln('   -u, --user', log.gray(' # List repos for the specified GitHub username.'));
    log.writeln('   -o, --org', log.gray('  # List repos for the specified GitHub org.'));
    log.writeln('   -d, --dest', log.gray(' # The destination file. Default is `repos.json`'));
    log.writeln();
  }
};


// Use `-v` or `--verbose` for verbose logging
log.mode.verbose = argv.v || argv.verbose || false;
var help = argv.h || argv.help;

if (help) {
  displayHelp();
}


function handler (env) {
  var argvEnv = env.argv,
    cliPackage  = require('../package'),
    versionFlag = argvEnv.version,
    verbose     = argvEnv.v || argvEnv.verbose,
    verbConfig  = argvEnv.config,
    verbfile,
    verb;


  // Make the cwd the root of the current project,
  // regardless of where the command was run.
  process.chdir(cwd(env.cwd));


  if (typeof env.configBase === 'undefined') {
    env.configBase = env.cwd;
  }

  /**
   * Local verb > node_modules/verb
   */

  if (!env.modulePath) {
    log.error('  No local verb found in', chalk.yellow(env.cwd));
    log.error('  Please run: \'npm install verb --save-dev\'');
    process.exit(1);
  }

  verb = require(env.modulePath);

  /**
   * Update Verb's `runner` metadata with info about the
   * current tool, e.g. `verb-cli`. Use in templates with
   * the `runner.name` and `runner.url` variables.
   *
   * This is useful for generating stuff like:
   *
   *   _Generated by [verb-cli](https://github.com/assemble/verb-cli), on March 21, 2014._
   *
   * @api public
   */

  verb.runner = {
    name: "verb-cli",
    url: 'https://github.com/assemble/verb-cli'
  };

  if (verbose) {
    verb.mode.verbose = true;
  }

  // Show the context in the console.
  if (verbConfig) {
    log.writeln(verb);
  }

  if (versionFlag) {
    log.writeln();
    log.writeln(log.gray('  verb-cli\t', 'v') + cliPackage.version);
    if (env.modulePackage) {
      log.writeln(log.gray('  local verb\t', 'v') + env.modulePackage.version);
    }
    process.exit(0);
  }


  /**
   * Runtime config file
   *
   * Used to supply metadata to templates and
   * to configure options.
   */
  var matter;
  if (file.exists('.verbrc.md')) {
    matter = verb.matter(file.readFileSync('.verbrc.md'));
    if (matter.context && _.keys(matter.context).length > 0) {
      verb.verbrc = matter.context;
    }
  } else {
    verb.verbrc = localConfig;
  }

  // if (file.exists('.assemblerc.yml')) {
  //   var assemblerc = file.readYAMLSync('.assemblerc.yml');
  //   if (assemblerc.verb) {
  //     verb.verbrc = assemblerc.verb;
  //   }
  // }


  var opts = {
    ext: '.md', // dest extension
    cwd: env.configBase,
    prefixBase: true,
    destBase: env.cwd,
    verbose: verbose || false,
  };

  verb.init(opts);

  /**
   * verfile.js / .verbrc / .verbrc.yml
   */

  if (env.configPath) {
    if(env.configPath.indexOf('.js') !== -1) {
      log.writeln(log.bold('\n  Loading verbfile'), log.sep, file.normalizeSlash(env.configPath));
      verbfile = require(env.configPath)(verb);
    } else if (env.configPath.indexOf('.verbrc') !== -1) {
      log.writeln(log.bold('\n  Loading Verb config'), log.sep, file.normalizeSlash(env.configPath));
      verbfile = verb.verbrc;

      // Extend the default options with
      // the contents of the config file.
      _.extend(opts, verbfile);
    }
  }


  // Skip the default verb-cli task by defining `readme: false`
  if(opts.readme === false) {
    log.warn('  skipping default task.');
    return;
  }


  var dir  = argv.dir || opts.docs;
  var ext  = argv.e || argv.ext;
  var src  = argv._[0] || argv.s || argv.src;
  var dest = argv._[1] || argv.d || argv.dest || opts.dest;

  if (src && !file.hasExt(src)) {
    src = src + (ext || opts.ext);
  }

  console.log(file.expand(opts.docs));


  // Specify the docs dir with --dir
  var docsBase = path.resolve(env.configBase, dir || verb.docs);

  var docs = docsBase;
  if (!file.hasExt(docsBase)) {
    docs = docsBase;
  }

  if (src) {
    docs = src;
  }


  /**
   * Default task.
   */

  // Task start
  log.write();
  var files = file.expand(docs, opts);

  if (matter) {
    var dest =  'README.md';
    var output = verb.process(matter.content, opts).content;
    if (matter.context && matter.context.dest) {
      dest = matter.context.dest;
    }
    log.inform('writing', relative(env.configBase, dest));
    file.writeFileSync(relative(env.configBase, dest), output);
  } else if (!files.length) {
    log.warn(msg.noTemplates(docs));
  } else {
    files.map(function (filepath) {
      log.subhead('reading', relative(file.normalizeSlash(filepath)));

      verb.options = verb.options || {};
      var name = file.base(filepath) + opts.ext;
      var destination = dest || path.join(cwd(opts.destBase), name);

      verb.options.src = filepath;
      verb.options.dest = destination;
      _.extend(verb.options, opts);

      log.inform('writing', relative(env.configBase, destination));
      file.writeFileSync(destination, verb.read(filepath, verb.options));
    });
  }

  // Log a success message.
  log.done('done');
  return;
}

cli.launch(handler);